ENVCONF=env.conf
REPDEL='|'

# =========================
# logging
# =========================

logfile() {
    local -r MESS="$1"
}

log() {
    local -r MESS="$1"
    logfile "$MESS"
    echo $MESS
}

logfail() {
    log "$1"
    exit 4
}

execute_withlog() {
    local -r CMD="$@"
    log "$CMD"
    eval $CMD
    if [ $? -ne 0 ]; then
        # log CMD again, it can preceded by bunch of logs
        log "$CMD"
        logfail "Job failed"
    fi
}

# =============================
# temporary files
# =============================

crtemp() {
  local -r TMP=`mktemp`
  echo $TMP >>$TMPSTORE
  echo $TMP
}

# =============================
# different report functions
# =============================

getsec() {
  echo `date  +"%s"`
}


calculatesec() {
  local -r before=$1
  local -r after=`getsec`
  echo $(expr $after - $before)
}

getdate() {
    echo `date +"%Y-%m-%d %H-%M-%S"`
}



tsp() {
    local -r MESS="$1"
    local -r LEN=$2
    local -r OUT=`printf "%-${LEN}s $REPDEL" "$MESS"`
    echo "$OUT"
}

NAMELEN=20
DATELEN=20
SECLEN=10


printline() {
    echo -n $REPDEL >>$REPORTFILE
    while true; do
        [ -z "$1" ] && break
        O=`tsp "$1" $2`
        echo -n "$O" >>$REPORTFILE
        shift 2
    done
    echo >>$REPORTFILE
}

testbeg() {
    local -r subtest=$1
    if [ ! -f $REPORTFILE ]; then
        printline TEST $NAMELEN SUBTEST $NAMELEN START $DATELEN END $DATELEN TIME/SEC $SECLEN
    fi 
    local -r BEG="$subtest,`getdate`,`getsec`"
    echo $BEG
}

testend() {
    IFS=',' read -r subtest begdate begsec <<<$@
#    cho "$REPDEL $TESTNAME $REPDEL $subtest $REPDEL $begdate $REPDEL `getdate` $REPDEL `calculatesec $begsec` $REPDEL" >> $REPORTFILE
    printline $TESTNAME $NAMELEN $subtest $NAMELEN "$begdate" $DATELEN "`getdate`" $DATELEN "`calculatesec $begsec`" $SECLEN
}

# ========================
# misc script utilties
# ========================

required_var() {
    local -r VARIABLE=$1
    [ -z "${!VARIABLE}" ] && logfail "Need to set environment variable $VARIABLE"    
}

required_listofvars() {
    while true; do
        var=$1
        [ -z "$var" ] && break
        required_var $var
        shift
    done
}

required_par() {
    local -r PAR=$1
    [ -z "${!PAR}" ] && logfail "$PAR not set in $ENVCONF"
    [ "${!PAR}" == "-" ] && logfail "$PAR not set in $ENVCONF"
}

required_listofpars() {
    while true; do
        par=$1
        [ -z "$par" ] && break
        required_par $par
        shift
    done
}

log_listofpars() {
    while true; do
        par=$1
        [ -z "$par" ] && break
        val=${!par}
        log "$par=$val"
        shift
    done
}



existfile() {
    local -r FILENAME=$1
    [ -f $FILENAME ] || logfail "$FILENAME does not exist"
}

existexefile() {
    local -r FILENAME=$1
    [ -x $FILENAME ] || logfail "$FILENAME is not executable"
}

existdir() {
    local -r DIRNAME=$1
    [ -d $DIRNAME ] || logfail "$DIRNAME does not exist"
}


setenv() {
    source $ENVRC
}

onthelist() {
    local -r word=$1
    local -r list=$2
    for w in ${list//,/ }; do
        [ $w == $word ] &&  return
    done
    logfail "$word is not on the list $list"
}

getconfvar() {
    declare -A arr

    # read file line by line. Field separator is "="
    while IFS='=' read -r k v; do
        [ -z "$k" ] && continue
        [ -z "$v" ] && continue
        arr[$k]=$v
    done <$ENVCONF
    res=""
    while true; do
        key=$1
        [ -z "$key" ] && break
        val=${arr[$BENCHSIZE.$key]}
        if [ -z "$val" ]; then val=${arr[$key]}; fi
        if [ -z "$val" ]; then logfile "$1 variable not found in $ENVCONF"; val="-";  fi
        res="$res $val"
        shift
    done
    echo $res
}


# ==========================
# Hadoop functions
# ==========================

rmr_hdfs() {
    local -r DIR=$1
    local CMD="hdfs dfs -rm -r -f -skipTrash $DIR"
    execute_withlog ${CMD}
}

yarn_job() {
    local CMD="yarn $@"
    execute_withlog ${CMD}
}

yarn_job_examples() {
    local CMD="jar $HADOOPEXAMPLES $@"
    yarn_job ${CMD}
}

hivesql() {
    local CMD="beeline -e \"$@\""
    execute_withlog ${CMD}
}

pigscript() {
    local CMD="pig -f $1"
    execute_withlog ${CMD}
}

sparkshell() {
    local CMD="echo :quit | spark-shell -i $@"
    execute_withlog ${CMD}
}

sparksql() {
    local CMD="echo exit | spark-sql -i $@"
    execute_withlog ${CMD}
}